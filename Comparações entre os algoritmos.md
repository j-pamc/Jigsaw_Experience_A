# Por que o Quick Sort é preferível ao MergeSort para classificar matrizes  ?

A classificação rápida em sua forma geral é uma classificação no local (ou seja, não requer nenhum armazenamento extra), enquanto a classificação por mesclagem requer O(N) armazenamento extra, N denotando o tamanho da matriz que pode ser bastante caro. Alocar e desalocar o espaço extra usado para classificação por mesclagem aumenta o tempo de execução do algoritmo. Comparando a complexidade média, descobrimos que ambos os tipos têm complexidade média O(NlogN), mas as constantes diferem. Para arrays, a classificação por mesclagem perde devido ao uso de espaço de armazenamento O(N) extra. 
A maioria das implementações práticas do Quick Sort usa a versão aleatória. A versão randomizada tem complexidade de tempo esperada de O(nLogn). O pior caso também é possível na versão aleatória, mas o pior caso não ocorre para um padrão específico (como matriz classificada) e o Quick Sort aleatório funciona bem na prática.
O Quick Sort também é um algoritmo de classificação amigável ao cache, pois possui boa localidade de referência quando usado para arrays. 
O Quick Sort também é recursivo de cauda, ​​portanto, as otimizações de chamada de cauda são feitas.

# Por que o MergeSort é preferível ao QuickSort para listas vinculadas? 

No caso de listas vinculadas, o caso é diferente principalmente devido à diferença na alocação de memória de arrays e listas vinculadas. Ao contrário das matrizes, os nós da lista encadeada podem não estar adjacentes na memória. Ao contrário do array, na lista encadeada, podemos inserir itens no meio em O(1) espaço extra e O(1) tempo. Portanto, a operação de mesclagem de classificação por mesclagem pode ser implementada sem espaço extra para listas vinculadas.
Em arrays, podemos fazer acesso aleatório, pois os elementos são contínuos na memória. Digamos que temos um array inteiro (4 bytes) A ​​e deixe o endereço de A[0] ser x então para acessar A[i], podemos acessar diretamente a memória em (x + i*4). Ao contrário dos arrays, não podemos fazer acesso aleatório na lista encadeada. O Quick Sort requer muito desse tipo de acesso. Na lista vinculada para acessar o índice i'th, temos que percorrer cada nó da cabeça ao nó i'th, pois não temos um bloco contínuo de memória. Portanto, a sobrecarga aumenta para classificação rápida. O Merge sort acessa os dados sequencialmente e a necessidade de acesso aleatório é baixa. 